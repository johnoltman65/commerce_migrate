<?php

/**
 * @file
 * Contains commerce_migrate_ubercart.module.
 */

use Drupal\commerce_migrate\Utility;
use Drupal\commerce_migrate_ubercart\Plugin\migrate\source\uc6\ProductType;
use Drupal\field\Plugin\migrate\source\d6\Field as D6Field;
use Drupal\field\Plugin\migrate\source\d7\Field as D7Field;
use Drupal\field\Plugin\migrate\source\d6\FieldInstance;
use Drupal\field\Plugin\migrate\source\d6\FieldInstancePerViewMode;
use Drupal\field\Plugin\migrate\source\d6\FieldInstancePerFormDisplay;
use Drupal\language\Plugin\migrate\source\d6\LanguageContentSettings;
use Drupal\migrate\Exception\RequirementsException;
use Drupal\migrate_drupal\Plugin\migrate\FieldMigration;
use Drupal\node\Plugin\migrate\source\d6\Node;
use Drupal\node\Plugin\migrate\source\d6\NodeRevision;
use Drupal\node\Plugin\migrate\source\d6\NodeType;
use Drupal\node\Plugin\migrate\source\d6\ViewMode;
use Drupal\taxonomy\Plugin\migrate\source\d6\TermNode;

/**
 * Implements hook_migration_plugins_alter().
 *
 * Since products are nodes in Ubercart 6 the field and node migration need
 * extra information so there is no duplication of products as nodes. This is
 * accomplished by alterations to the node type, node and field migrations as
 * well as using the prepareRow event.
 *
 * Briefly, node type will skip product type rows. The counterpart is the
 * migration uc6_product_type which will only return product node types.
 * The field migrations are aware of the destination entity and bundle. Finally,
 * the destination on the derived node migrations is changed to the correct
 * entity.
 *
 * Node type: Add a process that skips the row if the the source property
 * 'product_type' is NULL.
 * Field: Alter the entity type process so that the entity type can be set up in
 * the prepareRow event. And add a process so an field storage entity can be
 * made in the process, not the destination.
 * Field instance, Field formatter, Field widget: Alter the entity type process
 * so that the entity type can be set up in the prepareRow event. Add a process
 * that determines the bundle type.
 * View mode: Alter the entity type process so that the entity type can be set
 * up in the prepareRow event.
 * Node: For product type node migrations alter the source and destination
 * plugins. And add processes for product specific properties.
 *
 * See also UC6NodeFieldMigrationEventSubscriber::prepareRow.
 */
function commerce_migrate_ubercart_migration_plugins_alter(&$migrations) {
  // Remove payment migration when commerce_price is not installed.
  /** @var \Drupal\Core\Extension\ModuleHandlerInterface $moduleHandler */
  $moduleHandler = \Drupal::service('module_handler');
  if (!$moduleHandler->moduleExists('commerce_price')) {
    unset($migrations['uc6_payment_gateway']);
    unset($migrations['uc6_payment']);
  }

  // Ubercart 6 stored products as nodes. Modify the node migrations so that
  // products are saved as a commerce_product entity. Modify the field
  // migrations so that fields on products are saved as commerce fields not
  // node fields.
  foreach ($migrations as $key => &$migration) {
    /** @var \Drupal\migrate\Plugin\MigratePluginManager $migration_plugin_manager */
    $migration_plugin_manager = \Drupal::service('plugin.manager.migration');
    $migration_stub = $migration_plugin_manager->createStubMigration($migration);
    /** @var \Drupal\migrate\Plugin\MigrateSourcePluginManager $source_plugin_manager */
    $source_plugin_manager = \Drupal::service('plugin.manager.migrate.source');
    $configuration = $migration['source'];
    $source = $source_plugin_manager->createInstance($migration['source']['plugin'], $configuration, $migration_stub);

    // Node type or Term node.
    if (Utility::classInArray($source, [NodeType::class, TermNode::class]) &&
      (get_class($source) != ProductType::class)) {
      // Add process so that the row will be skipped if is a product type.
      $migration['process']['product_type'] = [
        [
          'plugin' => 'skip_on_empty',
          'source' => 'product_type',
          'method' => 'row',
        ],
      ];
    }

    if (is_a($source, LanguageContentSettings::class)) {
      // There are two language content settings migrations, one for node types
      // of type node and one for nodes that are products. Add a process to each
      // so that process can determine which rows to skip, because they are not
      // the type matching the destination. Two migrations are needed because
      // d6_language_content_settings has a destination configuration value,
      // content_translation_update_definitions, that is not changeable in the
      // process pipeline.
      // @todo Update when https://www.drupal.org/node/2930050 is resolved.
      $migration['process']['product_type'] = [
        [
          'plugin' => 'skip_on_empty',
          'source' => 'product_type',
          'method' => 'row',
        ],
      ];
    }

    // Alter d6_field or d7_field so the storage is on the correct entity.
    if (is_a($migration['class'], FieldMigration::class, TRUE)) {
      // Field storage.
      if (Utility::classInArray($source, [D6Field::class, D7Field::class])) {
        $migration['process']['entity_type'] = 'entity_type';
        // Add a process so it is possible to create both a node and product
        // field storage for the given field.
        $migrations[$key]['process']['ubercart_field_storage'] = [
          'plugin' => 'uc_field_storage_generate',
          'source' => 'ubercart_entity_type',
        ];
      }

      // Field instance, field formatter, field instance widget settings.
      if (Utility::classInArray($source, [
        FieldInstance::class,
        FieldInstancePerViewMode::class,
        FieldInstancePerFormDisplay::class,
      ], FALSE)) {
        $migration['process']['entity_type'] = 'entity_type';
        // Add processing to determine tne bundle.
        $migration['process'] = _commerce_migrate_ubercart_alter_entity_type_process($migration['process'], 'bundle');
        $migration['migration_dependencies']['required'][] = 'uc6_product_type';
      }
    }

    // View mode.
    if (is_a($source, ViewMode::class)) {
      // Change the source plugin so that the type name can be added to the row.
      // This will allow the process pipeline to determine if the row is for
      // a node type that is a product or a node.
      $migration['source']['plugin'] = 'uc6_view_mode';
      $migration['process']['targetEntityType'] = 'entity_type';
      $migration['migration_dependencies']['required'][] = 'uc6_product_type';
    }

    if (is_a($source, Node::class)) {
      if (isset($migration['source']['node_type'])) {
        // Modify the process for all node migrations that are products.
        $node_type = $migration['source']['node_type'];
        $product_node_types = _commerce_migrate_ubercart_get_product_node_types($migrations);
        if (in_array($node_type, $product_node_types)) {
          // This is a node type for a product so alter the migration.
          $migration['source']['plugin'] = 'uc6_product';
          $migration['process']['product_id'] = 'tnid';
          $migration['process']['type'] = 'type';
          // Add product specific processes.
          $migration['process']['variations/target_id'] = [
            [
              'plugin' => 'migration_lookup',
              'migration' => 'uc6_product_variation',
              'source' => 'tnid',
            ],
            [
              'plugin' => 'skip_on_empty',
              'method' => 'row',
            ],
          ];
          $migration['process']['stores/target_id'] = 'stores';
          $migration['destination']['plugin'] = 'entity:commerce_product';
          $migration['migration_dependencies']['required'][] = 'uc6_store';
          $migration['migration_dependencies']['required'][] = 'uc6_product_variation';

          // Products in D8 do not support revisions.
          if (is_a($source, NodeRevision::class)) {
            unset($migrations[$key]);
          }
        }
      }
    }
  }
}

/**
 * Get the node types that are products.
 *
 * @param array $migrations
 *   An array of all migrations.
 *
 * @return array
 *   An array of node types that are product types.
 */
function _commerce_migrate_ubercart_get_product_node_types(array $migrations) {
  $source_plugin = \Drupal::service('plugin.manager.migration')
    ->createStubMigration($migrations['uc6_store'])
    ->getSourcePlugin();
  $product_node_types = [];
  $connection = NULL;
  try {
    $connection = $source_plugin->getDatabase();
  }
  catch (RequirementsException $e) {
    // It is possible the commerce_migrate is enabled to use the supplied
    // plugins, but the migrations are not configured. In this case, the
    // exported configurations are not available to swap out the default
    // sql source key of 'migrate'.
  }
  if ($connection) {
    if ($connection->schema()->tableExists('node_type')) {
      $query = $connection->select('node_type', 'nt')
        ->fields('nt', ['type'])
        ->condition('module', 'uc_product%', 'LIKE')
        ->distinct();
      $product_node_types = $query->execute()->fetchCol();
    }
  }
  return $product_node_types;
}

/**
 * Returns the migration process for determining the entity type.
 *
 * @param array $process
 *   The migration process to modify.
 * @param string $destination_name
 *   The destination name.
 *
 * @return array
 *   The altered migration process.
 */
function _commerce_migrate_ubercart_alter_entity_type_process(array $process, $destination_name) {
  $process['node_type'] =
    [
      'plugin' => 'migration_lookup',
      'migration' => 'd6_node_type',
      'source' => 'type_name',
    ];
  $process['product_node_type'] =
    [
      'plugin' => 'migration_lookup',
      'migration' => 'uc6_product_type',
      'source' => 'type_name',
    ];
  // Ensure bundle is run last.
  unset($process[$destination_name]);
  // Only one of node_type and product_type should be a non null value.
  // Use that value as the bundle. Include a skip_on_empty as a
  // precaution.
  $process[$destination_name] = [
    [
      'plugin' => 'callback',
      'source' => ['@node_type', '@product_node_type'],
      'callable' => 'array_filter',
    ],
    [
      'plugin' => 'callback',
      'callable' => 'current',
    ],
    [
      'plugin' => 'skip_on_empty',
      'method' => 'row',
    ],
  ];
  return $process;
}
